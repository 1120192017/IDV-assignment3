<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>All Charts — Combined</title>
  <script src="https://cdn.jsdelivr.net/npm/d3@7"></script>
  <style>
    /* ======= 全局框架与导航 ======= */
    :root{
      --bg:#e8f0ef;
      --card:#ffffff;
      --shadow:0 6px 20px rgba(0,0,0,.08);
      --title:#0f172a;
    }
    html,body{margin:0;background:var(--bg);font-family:ui-sans-serif,system-ui,-apple-system,"Segoe UI",Roboto,Arial}
    header{position:sticky;top:0;background:var(--card);padding:14px 18px;box-shadow:0 2px 10px rgba(0,0,0,.05);z-index:10}
    header h1{margin:0;font-size:18px;color:var(--title)}
    nav{margin-top:8px;display:flex;flex-wrap:wrap;gap:10px}
    nav a{padding:8px 10px;border-radius:10px;background:#0ea5e9;color:#fff;text-decoration:none;font-size:13px}
    main{padding:18px}
    section{background:var(--card);border-radius:14px;box-shadow:var(--shadow);padding:16px 16px 18px;margin:18px auto;max-width:1200px}
    section h2{margin:6px 2px 12px;font-size:18px}
    .hint{font-size:12px;color:#334155}

    /* ======= Chart 1 (vector space) —— 作用域选择器前缀 .c1 ======= */
    .c1 .wrap{display:flex;gap:14px}
    .c1 #c1-chart{width:calc(100% - 280px)}
    .c1 #c1-legend{width:260px}
    .c1 button{padding:8px 12px;border:0;border-radius:10px;cursor:pointer}
    .c1 .btn{background:#0ea5e9;color:#fff}
    .c1 .btn:active{opacity:.85}
    .c1 .grid line{stroke:#bfc9c8;stroke-opacity:.6}
    .c1 .border{stroke:#8aa5a2;fill:none;stroke-width:2}
    .c1 .point{fill:#0f172a}
    .c1 .label{font-weight:700;fill:#0f172a}
    .c1 .v-solid{stroke:#4b5563;stroke-width:2.5}
    .c1 .v-dash1{stroke:#223f6a;stroke-dasharray:5 6;stroke-width:3}
    .c1 .v-dash2{stroke:#1e8aa3;stroke-dasharray:5 6;stroke-width:3}
    .c1 .arrowhead{fill:currentColor}

    /* ======= Chart 7 (Venn) —— 作用域前缀 .c7 ======= */
    .c7 .stage{display:flex;align-items:center;justify-content:center}
    .c7 svg{display:block;width:1100px;height:700px;background:#fff;box-shadow:0 2px 12px rgba(0,0,0,.06)}
    .c7 .label{font-size:26px;fill:#000}
    .c7 .roman{font-size:30px;font-weight:700;fill:#000}
    .c7 .set{stroke:#6b6b6b;stroke-opacity:.35;stroke-width:1.2px;cursor:pointer}
    .c7 .tooltip{position:fixed;pointer-events:none;padding:6px 10px;background:#222;color:#fff;border-radius:6px;font-size:13px;opacity:0;transition:opacity .15s ease}

    /* ======= Chart 8 (Bars) —— 前缀 .c8 ======= */
    .c8 .wrap{width:980px;margin:0 auto}
    .c8 h3{margin:8px 0 12px;text-align:center;font-weight:700;letter-spacing:.2px}
    .c8 svg{display:block;margin:auto;background:#fafafa}
    .c8 .frame{stroke:#7a7a7a;stroke-width:4;fill:none}
    .c8 .axis text{font-size:16px;fill:#000}
    .c8 .axis path,.c8 .axis line{stroke:#7a7a7a;stroke-width:4}
    .c8 .y-axis .domain{display:none}
    .c8 .x-axis .tick line{display:none}
    .c8 .bar{fill:#e0c35a;stroke:#7a7a7a;stroke-width:3}
    .c8 .ghostBox{fill:none;stroke:#e0c35a;stroke-width:4;stroke-dasharray:10 8;opacity:.9}
    .c8 .label{font-size:22px;font-weight:700;fill:#000;stroke:none}
    .c8 .model{font-size:24px;font-weight:700}
    .c8 .tick100-left,.c8 .tick100-right{stroke:#7a7a7a;stroke-width:6}
    .c8 .tooltip{position:absolute;pointer-events:none;background:#222;color:#fff;padding:6px 10px;border-radius:8px;font:14px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Arial;box-shadow:0 4px 14px rgba(0,0,0,.25);opacity:0;transition:opacity .15s ease}

    /* ======= PDF Overlap —— 前缀 .pdfx ======= */
    .pdfx .axis path,.pdfx .axis line{stroke:#333;}
    .pdfx .tick text{fill:#000;}
    .pdfx .grid line{stroke:#d9d9d9;shape-rendering:crispEdges;}
    .pdfx .vline{stroke:#333;stroke-dasharray:6 6;}
    .pdfx .baseline{stroke:#333;stroke-dasharray:6 6;}
    .pdfx .area-left,.pdfx .area-right,.pdfx .area-between{fill:#bdbdbd;opacity:.6;}
    .pdfx .area-mid{fill:#6e6e6e;opacity:.65;}
    .pdfx .legend text{font-size:22px;}
    .pdfx .legend-line{stroke-width:6;fill:none;}
    .pdfx .tip{position:absolute;pointer-events:none;background:#222;color:#fff;border-radius:8px;padding:6px 8px;font:13px system-ui,-apple-system,Segoe UI,Roboto,Arial;opacity:0;transition:opacity .15s ease}

    /* ======= Frequency over time —— 前缀 .freq ======= */
    .freq svg{width:100%;height:340px;display:block}
    .freq .axis path.domain{stroke:#000;stroke-width:2;fill:none}
    .freq .axis .tick line{display:none}
    .freq .axis text{fill:#000;font-size:14px}
    .freq .y-label{font-size:20px;fill:#000}
    .freq .legend{font-size:20px}
    .freq .series-area{stroke:#000;stroke-opacity:.25;stroke-width:1}
    .freq .series-area.dim{opacity:.18}
    .freq .series-area.highlight{opacity:.95;stroke-opacity:.6}
    .freq .tooltip{position:absolute;pointer-events:none;background:rgba(255,255,255,.95);border:1px solid #ccc;border-radius:8px;padding:8px 10px;font-size:13px;box-shadow:0 2px 8px rgba(0,0,0,.12)}
  </style>
</head>
<body>
  <header>
    <h1>All Charts — Combined</h1>
    <nav>
      <a href="#chart1">Chart 1 (vector space)</a>
      <a href="#freq">Chart 4 (frequency)</a>
      <a href="#chart7">Chart 7 (Venn)</a>
      <a href="#chart8">Chart 8 (simple bars)</a>
      <a href="#pdf-overlap">Chart 11 (function)</a>
    </nav>
  </header>

  <main>
    <!-- ========== Chart 1 (vector space) ========== -->
    <section id="chart1" class="c1">
      <h2>Chart 1 (vector space)</h2>
      <div class="wrap">
        <div id="c1-chart">
          <svg id="c1-svg" viewBox="0 0 900 500"></svg>
          <div class="hint">Interaction: drag the teal/blue dashed vectors' end points to see updates. Transition: vectors animate on load.</div>
        </div>
        <div id="c1-legend">
          <div style="display:flex; gap:8px; align-items:center; margin-bottom:10px">
            <button id="c1-replay" class="btn">Replay transition</button>
            <button id="c1-toggle" class="btn" style="background:#10b981">Toggle dashed</button>
          </div>
          <div>
            <svg width="220" height="120">
              <defs>
                <marker id="c1-lgArrow" viewBox="0 0 10 10" refX="10" refY="5" markerWidth="8" markerHeight="8" orient="auto-start-reverse">
                  <path d="M 0 0 L 10 5 L 0 10 z" fill="currentColor"></path>
                </marker>
              </defs>
              <line x1="15" y1="25" x2="95" y2="25" stroke="#4b5563" stroke-width="3" marker-end="url(#c1-lgArrow)"/>
              <text x="105" y="30">solid vector</text>
              <line x1="15" y1="60" x2="95" y2="60" stroke="#223f6a" stroke-width="3" stroke-dasharray="5 6" marker-end="url(#c1-lgArrow)"/>
              <text x="105" y="65">dashed (blue)</text>
              <line x1="15" y1="95" x2="95" y2="95" stroke="#1e8aa3" stroke-width="3" stroke-dasharray="5 6" marker-end="url(#c1-lgArrow)"/>
              <text x="105" y="100">dashed (teal)</text>
            </svg>
          </div>
          <p style="font-size:12px; color:#475569; line-height:1.25">Drag handles on dashed vectors' tips to explore—grid snapping keeps them aligned. Labels use SVG <tspan> for Greek-like styling.</p>
        </div>
      </div>
      <script>
      (function(){
        const svg = d3.select('#c1-svg');
        const W = 900, H = 500, pad = 30;
        const cols = 12, rows = 6; // grid
        const x = d3.scaleLinear().domain([0, cols]).range([pad, W-pad]);
        const y = d3.scaleLinear().domain([0, rows]).range([H-pad, pad]); // flip y

        // --- Draw grid ---
        const g = svg.append('g');
        g.append('rect').attr('class','border').attr('x', x(0)).attr('y', y(rows))
          .attr('width', x(cols)-x(0)).attr('height', y(0)-y(rows));
        const grid = g.append('g').attr('class','grid');
        for(let i=0;i<=cols;i++) grid.append('line').attr('x1', x(i)).attr('y1', y(0)).attr('x2', x(i)).attr('y2', y(rows));
        for(let j=0;j<=rows;j++) grid.append('line').attr('x1', x(0)).attr('y1', y(j)).attr('x2', x(cols)).attr('y2', y(j));

        // --- Points & labels ---
        const pts = {
          a1: {x: 9, y: 3, label: 'e', super:'α', sub:'1'},
          a2: {x: 6, y: 3, label: 'e', super:'α', sub:'2'},
          b1: {x: 6, y: 1, label: 'e', super:'β', sub:'1'},
          b2: {x: 2, y: 1, label: 'e', super:'β', sub:'2'}
        };
        function drawLabel(g, p, dx=0, dy=0){
          const t = g.append('text').attr('class','label').attr('x', x(p.x)+dx).attr('y', y(p.y)+dy);
          t.append('tspan').text('e');
          t.append('tspan').text(p.super).attr('baseline-shift','super').style('font-size','70%').style('font-style','italic');
          t.append('tspan').text(p.sub).attr('baseline-shift','sub').style('font-size','70%');
        }

        // Marker
        svg.append('defs').append('marker')
          .attr('id','c1-arrow')
          .attr('viewBox','0 0 10 10')
          .attr('refX',10).attr('refY',5)
          .attr('markerWidth',8).attr('markerHeight',8)
          .attr('orient','auto-start-reverse')
          .append('path').attr('d','M 0 0 L 10 5 L 0 10 z').attr('class','arrowhead');

        const pg = svg.append('g');
        Object.values(pts).forEach(p=>{
          pg.append('circle').attr('class','point').attr('r',3.2).attr('cx',x(p.x)).attr('cy',y(p.y));
          const off = {a1:[6,-6], a2:[-4,-10], b1:[6,12], b2:[-10,12]};
          const key = Object.entries(pts).find(([k,v])=>v===p)[0];
          drawLabel(pg, p, off[key][0], off[key][1]);
        });

        // Parallelogram horizontal edges
        const para = svg.append('g');
        para.append('line')
          .attr('x1', x(pts.a2.x)).attr('y1', y(pts.a2.y))
          .attr('x2', x(pts.a1.x)).attr('y2', y(pts.a1.y))
          .attr('stroke', '#6b7280').attr('stroke-width', 2).attr('opacity', 0.9);
        para.append('line')
          .attr('x1', x(pts.b2.x)).attr('y1', y(pts.b2.y))
          .attr('x2', x(pts.b1.x)).attr('y2', y(pts.b1.y))
          .attr('stroke', '#6b7280').attr('stroke-width', 2).attr('opacity', 0.9);

        const vectors = [
          {id:'s1', from: pts.b1, to: pts.a1, klass:'v-solid', color:'#4b5563'},
          {id:'s2', from: pts.b2, to: pts.a2, klass:'v-solid', color:'#4b5563'}
        ];
        const dashed = [
          {id:'d1', from: pts.a1, to: pts.b2, klass:'v-dash1', color:'#223f6a'},
          {id:'d2', from: pts.a2, to: pts.b1, klass:'v-dash2', color:'#1e8aa3'}
        ];
        const allVecs = vectors.concat(dashed);

        const vg = svg.append('g');
        function pathOf(v){ return `M ${x(v.from.x)},${y(v.from.y)} L ${x(v.to.x)},${y(v.to.y)}`; }

        allVecs.forEach(v => {
          const p = vg.append('path')
            .attr('class', v.klass)
            .attr('d', pathOf(v))
            .attr('stroke', v.color)
            .attr('fill','none')
            .attr('marker-end','url(#c1-arrow)')
            .attr('stroke-linecap','round')
            .attr('opacity',0.95)
            .attr('stroke-width', v.klass==='v-solid'?2.5:3);

          const len = p.node().getTotalLength();
          p.attr('stroke-dasharray', len + ' ' + len).attr('stroke-dashoffset', len)
           .transition().duration(1200).ease(d3.easeCubicInOut).attr('stroke-dashoffset', 0);

          v.el = p;
        });

        // Drag handles for dashed
        const handles = svg.append('g');
        dashed.forEach(v => {
          const h = handles.append('circle').attr('r',8).attr('fill','#0ea5e9').attr('opacity',.8)
            .attr('cx', x(v.to.x)).attr('cy', y(v.to.y)).style('cursor','grab');

          h.call(d3.drag()
            .on('start',()=>h.style('cursor','grabbing'))
            .on('drag', (event)=>{
              const xm = Math.round(x.invert(event.x));
              const ym = Math.round(y.invert(event.y));
              v.to.x = Math.max(0, Math.min(cols, xm));
              v.to.y = Math.max(0, Math.min(rows, ym));
              h.attr('cx', x(v.to.x)).attr('cy', y(v.to.y));
              v.el.attr('d', pathOf(v));
            })
            .on('end',()=>h.style('cursor','grab')));
        });

        // Controls
        d3.select('#c1-replay').on('click', () => {
          allVecs.forEach(v => {
            const p = v.el; const len = p.node().getTotalLength();
            p.interrupt().attr('stroke-dasharray', len + ' ' + len).attr('stroke-dashoffset', len)
             .transition().duration(900).ease(d3.easeCubicInOut).attr('stroke-dashoffset', 0);
          });
        });

        let dashOn = true;
        d3.select('#c1-toggle').on('click', () => {
          dashOn = !dashOn;
          dashed.forEach(v => v.el.transition().duration(250).style('opacity', dashOn? 0.95: 0));
        });
      })();
      </script>
    </section>

    <!-- ========== Chart 4 (frequency) ========== -->
    <section id="freq" class="freq">
      <h2>Chart 4 (frequency)</h2>
      <svg id="freq-svg" height="340"></svg>
      <script>
      (function () {
        const svg = d3.select("#freq-svg");

        const bbox = svg.node().getBoundingClientRect();
        const width  = (bbox && bbox.width)  ? bbox.width  - 66 - 28 : 1200 - 66 - 28;
        const height = +svg.attr("height");
        const margin = { top: 18, right: 28, bottom: 36, left: 66 };
        const innerH = height - margin.top - margin.bottom;

        const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

        const color = d3.scaleOrdinal()
          .domain(["Set model","Sequence model","Vector model","End-to-end"])
          .range(["#66c2a5","#fc8d62","#8da0cb","#e78ac3"]);

        const years = d3.range(1980, 2023);
        function spikes(map){
          const out = new Map();
          years.forEach(y=>out.set(y,0));
          for (const [y,v] of map) out.set(y,v);
          return years.map(y=>({year:y, value: out.get(y)}));
        }
        const data = [
          {key:"Set model", values: spikes([[1986,1],[1987,0.8],[2003,1.2],[2004,2.0],[2005,0.2]])},
          {key:"Sequence model", values: spikes([[1992,1.0],[2005,0.3],[2006,1.6],[2016,1.0],[2017,1.2],[2018,1.0],[2019,0.6]])},
          {key:"Vector model", values: spikes([[1989,1.0],[1999,1.0],[2003,0.8],[2004,1.6],[2009,2.0],[2013,3.2],[2014,4.8],[2015,2.2],[2016,5.0],[2017,3.6]])},
          {key:"End-to-end", values: spikes([[1995,0.8],[1996,1.2],[1997,1.0],[2006,0.8],[2007,2.0],[2012,1.2],[2013,5.0],[2014,2.4],[2015,3.0],[2016,4.2],[2017,4.0],[2018,10.0],[2019,2.2]])}
        ];

        const x = d3.scaleLinear().domain([1980, 2022]).range([0, width]);
        const y = d3.scaleLinear().domain([0, 10]).nice().range([innerH, 0]);
        const xAxis = d3.axisBottom(x).tickValues(d3.range(1980, 2025, 5)).tickFormat(d3.format("d"));
        const yAxis = d3.axisLeft(y).ticks(5);

        g.append("g").attr("class","axis x").attr("transform",`translate(0,${innerH})`).call(xAxis);
        g.append("g").attr("class","axis y").call(yAxis);
        g.append("text").attr("class","y-label").attr("transform","rotate(-90)")
          .attr("x",-innerH/2).attr("y",-48).attr("text-anchor","middle").text("Frequency");

        const area = d3.area()
          .x(d => x(d.year))
          .y0(y(0))
          .y1(d => y(d.value))
          .curve(d3.curveCatmullRom.alpha(0.7));

        const order = ["Set model","Sequence model","Vector model","End-to-end"];

        const seriesG = g.append("g").attr("clip-path","url(#freq-clip)");

        g.append("clipPath").attr("id","freq-clip")
          .append("rect").attr("width",0).attr("height",innerH)
          .transition().duration(1200).ease(d3.easeCubicOut).attr("width",width);

        const series = seriesG.selectAll(".series")
          .data(order.map(k => data.find(d=>d.key===k)))
          .join("g").attr("class","series");

        series.append("path")
          .attr("class","series-area")
          .attr("fill", d => color(d.key))
          .attr("fill-opacity", 0.6)
          .attr("d", d => area(d.values));

        const legend = g.append("g").attr("class","legend").attr("transform","translate(8,10)");
        const row = legend.selectAll("g.item")
          .data(order).join("g").attr("class","item")
          .attr("transform",(d,i)=>`translate(0,${i*30})`)
          .style("cursor","pointer")
          .on("mouseenter", (e,key)=> highlight(key))
          .on("mouseleave", unhighlight)
          .on("click", (e,key)=> toggle(key));

        row.append("rect").attr("x",0).attr("y",-18).attr("width",26).attr("height",18)
          .attr("fill", d=>color(d)).attr("fill-opacity",0.6)
          .attr("stroke","#000").attr("stroke-opacity",.25);
        row.append("text").attr("x",36).attr("y",-4).attr("dominant-baseline","middle").text(d=>d);

        const tooltip = d3.select("body").append("div").attr("class","freq tooltip").style("opacity",0);
        const focusLine = g.append("line").attr("y1",0).attr("y2",innerH)
          .attr("stroke","#000").attr("stroke-opacity",.15).style("display","none");

        svg.on("mousemove", (event)=>{
          const [mx] = d3.pointer(event, g.node());
          const year = Math.max(1980, Math.min(2022, Math.round(x.invert(mx))));
          focusLine.attr("x1", x(year)).attr("x2", x(year)).style("display", null);

          const rows = order.map(k=>{
            const arr = data.find(d=>d.key===k).values;
            const v = arr.find(d=>d.year===year)?.value ?? 0;
            return {k, v};
          });

          tooltip.style("opacity",1).style("left",(event.pageX+14)+"px").style("top",(event.pageY-10)+"px")
            .html(`<b>${year}</b><br>` + rows.map(r =>
              `<span style="display:inline-block;width:10px;height:10px;background:${color(r.k)};opacity:.6;margin-right:6px;border:1px solid rgba(0,0,0,.25)"></span>${r.k}: ${r.v.toFixed(1)}`
            ).join("<br>"));
        }).on("mouseleave", ()=>{
          tooltip.style("opacity",0); focusLine.style("display","none");
        });

        let hidden = new Set();
        function updateOpacity(){ series.select("path").classed("dim", d => hidden.has(d.key)); }
        function highlight(key){
          series.select("path")
            .classed("highlight", d => d.key===key && !hidden.has(d.key))
            .classed("dim", d => d.key!==key || hidden.has(d.key));
        }
        function unhighlight(){ series.select("path").classed("highlight", false).classed("dim", d => hidden.has(d.key)); }
        function toggle(key){
          if (hidden.has(key)) hidden.delete(key); else hidden.add(key);
          series.filter(d=>d.key===key).select("path")
            .transition().duration(250)
            .attr("fill-opacity", hidden.has(key)? 0.05 : 0.6);
          updateOpacity();
        }

        series.select("path")
          .attr("transform","translate(0," + (y(0)-y(0)) + ") scale(1,0)")
          .transition().delay(150).duration(900).ease(d3.easeCubicOut)
          .attr("transform","translate(0,0) scale(1,1)");
      })();
      </script>
    </section>

    <!-- ========== Chart 7 (Venn) ========== -->
    <section id="chart7" class="c7">
      <h2>Chart 7 (Venn)</h2>
      <div class="stage">
        <svg id="c7-venn" viewBox="0 0 1100 700" preserveAspectRatio="xMidYMid meet"></svg>
      </div>
      <div class="tooltip" id="c7-tip"></div>
      <script>
      (function(){
        const svg = d3.select("#c7-venn");
        const W = 1100, H = 700;
        const cx = { left: 380, top: 590, right: 730 };
        const cy = { left: 470, top: 300, right: 500 };
        const r = 220;
        const colors = { left:"#b8b2d9", top:"#c9b3b3", right:"#edd88c" };

        svg.append("rect").attr("x",40).attr("y",70).attr("width",W-80).attr("height",H-120).attr("fill","#fff");

        const sets = [
          {id:"left",  cx:cx.left,  cy:cy.left,  fill:colors.left,  name:"Delete"},
          {id:"top",   cx:cx.top,   cy:cy.top,   fill:colors.top,   name:"Replace"},
          {id:"right", cx:cx.right, cy:cy.right, fill:colors.right, name:"Rewrite"}
        ];

        const tip = d3.select("#c7-tip");

        svg.selectAll("circle.set")
          .data(sets).enter().append("circle")
          .attr("class","set").attr("id", d=>`c7-${d.id}`)
          .attr("cx", d=>d.cx).attr("cy", d=>d.cy).attr("r", r)
          .attr("fill", d=>d.fill).attr("opacity", 0)
          .transition().duration(800).attr("opacity", 0.55);

        svg.selectAll("circle.set")
          .on("mousemove", function(e,d){
              d3.select(this).attr("opacity", 0.75);
              tip.style("opacity",1).style("left",(e.clientX+12)+"px").style("top",(e.clientY+12)+"px").text(d.name);
          })
          .on("mouseout", function(){
              d3.select(this).attr("opacity", 0.55);
              tip.style("opacity",0);
          });

        svg.append("text").attr("class","label")
           .attr("x", cx.top).attr("y", 120).attr("text-anchor","middle").text("Replace");
        svg.append("text").attr("class","label")
           .attr("x", 140).attr("y", cy.left + 20).text("Delete");
        svg.append("text").attr("class","label")
           .attr("x", W - 180).attr("y", cy.right + 20).attr("text-anchor","end").text("Rewrite");

        placeRoman("I",   cx.left - 70,  cy.left + 130);
        placeRoman("II",  cx.top,        cy.top  + 20);
        placeRoman("III", cx.right + 60, cy.right + 110);
        placeRoman("IV",  (cx.left+cx.top)/2 - 30, (cy.left+cy.top)/2 + 10);
        placeRoman("V",   (cx.top+cx.right)/2 + 10, (cy.top+cy.right)/2 - 10);
        placeRoman("VI",  (cx.left+cx.right)/2 - 10, (cy.left+cy.right)/2 + 80);
        placeRoman("VII", (cx.left+cx.top+cx.right)/3 + 5, (cy.left+cy.top+cy.right)/3 + 30);

        function placeRoman(txt, x, y){
          svg.append("text").attr("class","roman").attr("x",x).attr("y",y).attr("text-anchor","middle").text(txt);
        }
      })();
      </script>
    </section>

    <!-- ========== Chart 8 (simple bars) ========== -->
    <section id="chart8" class="c8">
      <h2>Chart 8 (simple bars)</h2>
      <div class="wrap">
        <h3>Cross Validation Accuracy (%)</h3>
        <div id="c8-chart"></div>
      </div>
      <div class="tooltip" id="c8-tip"></div>
      <script>
      (function(){
        const data = [
          {model:"BERT",    solid:74.4, ghost:64.8},
          {model:"RoBERTa", solid:81.9, ghost:65.5},
          {model:"BART",    solid:73.1, ghost:63.5}
        ];
        const outerW = 900, outerH = 480;
        const margin = {top:40, right:40, bottom:80, left:70};
        const w = outerW - margin.left - margin.right;
        const h = outerH - margin.top - margin.bottom;

        const svg = d3.select("#c8-chart").append("svg")
          .attr("width", outerW).attr("height", outerH);
        const g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

        g.append("rect").attr("class","frame")
          .attr("x",0).attr("y",0).attr("width",w).attr("height",h);

        const y = d3.scaleLinear().domain([0,100]).nice().range([h,0]);
        const yAxis = d3.axisLeft(y).tickValues([0,100]).tickSize(0);
        g.append("g").attr("class","axis y-axis").call(yAxis)
          .selectAll("text").attr("dx",-8);

        g.append("g").attr("transform", `translate(${w},0)`)
          .append("line").attr("y1",0).attr("y2",h).attr("stroke","#7a7a7a").attr("stroke-width",4);

        const y100 = y(100);
        g.append("line").attr("class","tick100-left")
          .attr("x1",-6).attr("x2",0).attr("y1",y100).attr("y2",y100);
        g.append("line").attr("class","tick100-right")
          .attr("x1",w).attr("x2",w+6).attr("y1",y100).attr("y2",y100);

        const x = d3.scaleBand()
          .domain(data.map(d=>d.model))
          .range([0, w]).paddingInner(0.55).paddingOuter(0.25);
        const xAxis = d3.axisBottom(x);
        g.append("g").attr("class","axis x-axis")
          .attr("transform", `translate(0,${h})`).call(xAxis)
          .selectAll("text").attr("class","model").attr("dy","1.2em");

        const barW = Math.min(70, x.bandwidth()*0.55);
        const gap   = Math.min(16, x.bandwidth()*0.18);
        const tip = d3.select("#c8-tip");

        g.selectAll(".ghostBox")
          .data(data)
          .enter().append("rect")
          .attr("class","ghostBox")
          .attr("rx",6).attr("ry",6)
          .attr("x", d => x(d.model) + barW + gap)
          .attr("y", h)
          .attr("width", barW)
          .attr("height", 0)
          .on("mousemove", (ev,d)=>{
              tip.style("opacity",1)
                 .style("left", (ev.pageX+12)+"px")
                 .style("top",  (ev.pageY-10)+"px")
                 .html(`<b>${d.model}</b><br/>Ghost: ${d.ghost}%`);
          })
          .on("mouseleave", ()=> tip.style("opacity",0))
          .transition().duration(900).delay(250)
          .attr("y", d => y(d.ghost))
          .attr("height", d => h - y(d.ghost));

        g.selectAll(".bar")
          .data(data)
          .enter().append("rect")
          .attr("class","bar")
          .attr("x", d => x(d.model))
          .attr("y", h)
          .attr("width", barW)
          .attr("height", 0)
          .on("mousemove", (ev,d)=>{
              tip.style("opacity",1)
                 .style("left", (ev.pageX+12)+"px")
                 .style("top",  (ev.pageY-10)+"px")
                 .html(`<b>${d.model}</b><br/>Accuracy: ${d.solid}%`);
          })
          .on("mouseleave", ()=> tip.style("opacity",0))
          .transition().duration(900)
          .attr("y", d => y(d.solid))
          .attr("height", d => h - y(d.solid));

        g.selectAll(".label.solid")
          .data(data).enter()
          .append("text").attr("class","label solid")
          .attr("x", d => x(d.model)+barW/2)
          .attr("y", d => y(d.solid)-10)
          .attr("text-anchor","middle")
          .text(d => d.solid.toFixed(1));

        g.selectAll(".label.ghost")
          .data(data).enter()
          .append("text").attr("class","label ghost")
          .attr("x", d => x(d.model) + barW + gap + barW/2)
          .attr("y", d => y(d.ghost)-10)
          .attr("text-anchor","middle")
          .text(d => d.ghost.toFixed(1));
      })();
      </script>
    </section>

    <!-- ========== Chart 11 (function) ========== -->
    <section id="pdf-overlap" class="pdfx">
      <h2>Chart 11 (function)</h2>
      <div id="pdfx-chart"></div>
      <div id="pdfx-tip" class="tip"></div>
      <script>
      (function(){
        const W=1150,H=760,m={top:28,right:48,bottom:78,left:110};
        const iw=W-m.left-m.right, ih=H-m.top-m.bottom;

        const svg=d3.select('#pdfx-chart').append('svg').attr('width',W).attr('height',H);
        const g=svg.append('g').attr('transform',`translate(${m.left},${m.top})`);

        const x=d3.scaleLinear().domain([-2,5]).range([0,iw]);
        const y=d3.scaleLinear().domain([0,0.35]).range([ih,0]);

        // grid + axes
        g.append('g').attr('class','grid')
          .attr('transform',`translate(0,${ih})`)
          .call(d3.axisBottom(x).ticks(14).tickSize(-ih).tickFormat(''));
        g.append('g').attr('class','grid')
          .call(d3.axisLeft(y).ticks(8).tickSize(-iw).tickFormat(''));
        g.append('g').attr('class','axis').attr('transform',`translate(0,${ih})`).call(d3.axisBottom(x).ticks(14));
        g.append('g').attr('class','axis').call(d3.axisLeft(y).ticks(8));

        // labels
        g.append('text').attr('x',iw/2).attr('y',ih+52).attr('text-anchor','middle').attr('font-size',28).text('x');
        g.append('text').attr('transform','rotate(-90)').attr('x',-ih/2).attr('y',-70)
          .attr('text-anchor','middle').attr('font-size',28).text('Probability Density');

        // baseline + dashed verticals
        g.append('line').attr('class','baseline').attr('x1',0).attr('y1',y(0)).attr('x2',iw).attr('y2',y(0));
        const a=0.85,b=1.45;
        const vA=g.append('line').attr('class','vline').attr('x1',x(a)).attr('x2',x(a)).attr('y1',0).attr('y2',ih);
        const vB=g.append('line').attr('class','vline').attr('x1',x(b)).attr('x2',x(b)).attr('y1',0).attr('y2',ih);

        // pdfs
        const normal=(mu,s)=>z=>(1/(s*Math.sqrt(2*Math.PI)))*Math.exp(-0.5*((z-mu)/s)**2);
        const clampTiny=v=>v<1e-4?0:v;

        const pdf0_raw=normal(0.0,1.00), A0=0.59;   // 黄
        const pdf1_raw=normal(2.1,0.70), A1=0.44;   // 蓝
        // —— 黄线平滑起步：x<=x0 为 0；x0~x1 线性爬坡；x>=x1 用正态 —— 
        const x0=-1.35, x1=-1.10;
        function pdf0(xv){
          if(xv<=x0) return 0;
          if(xv<x1){
            const y1=A0*pdf0_raw(x1);
            const t=(xv-x0)/(x1-x0);          // 线性从 0 -> y1
            return t*y1;
          }
          return clampTiny(A0*pdf0_raw(xv));
        }
        function pdf1(xv){ return clampTiny(A1*pdf1_raw(xv)); }

        const xs=d3.range(-2,5.0001,0.01);

        // 曲线数据（首尾加0）
        const data0=[{x:-2,y:0},...xs.map(xx=>({x:xx,y:pdf0(xx)})),{x:5,y:0}];
        const data1=[{x:-2,y:0},...xs.map(xx=>({x:xx,y:pdf1(xx)})),{x:5,y:0}];

        const line=d3.line().x(d=>x(d.x)).y(d=>y(d.y)).curve(d3.curveMonotoneX);
        const area=d3.area().x(d=>x(d.x)).y0(y(0)).y1(d=>y(d.y)).curve(d3.curveMonotoneX);

        const col0='#f0b233', col1='#1f8a9e';

        // ===== 阴影 =====
        // 左段：[-2, a] 蓝线到基线（浅灰）
        const leftXs=xs.filter(v=>v<=a);
        const areaLeft=[{x:-2,y:0},...leftXs.map(v=>({x:v,y:pdf1(v)})),{x:a,y:pdf1(a)},{x:a,y:0}];
        g.append('path').datum(areaLeft).attr('class','area-left').attr('d',area);

        // 中段深灰：[a,b] min(pdf0,pdf1) 到基线
        const midXs=xs.filter(v=>v>=a && v<=b);
        const minArr=midXs.map(v=>({x:v,y:Math.min(pdf0(v),pdf1(v))}));
        const areaMid=[{x:a,y:0},{x:a,y:Math.min(pdf0(a),pdf1(a))},...minArr,{x:b,y:Math.min(pdf0(b),pdf1(b))},{x:b,y:0}];
        g.append('path').datum(areaMid).attr('class','area-mid').attr('d',area);

        // 中段浅灰（max-min）
        const maxArr=midXs.map(v=>({x:v,y:Math.max(pdf0(v),pdf1(v))}));
        const areaBetween=[{x:a,y:0},{x:a,y:Math.max(pdf0(a),pdf1(a))},...maxArr,{x:b,y:Math.max(pdf0(b),pdf1(b))},{x:b,y:0}];
        g.append('path').datum(areaBetween).attr('class','area-between').attr('d',area);  // 先画
        g.append('path').datum(areaMid).attr('class','area-mid').attr('d',area);          // 再把深灰盖上

        // 右段：[b,5] 黄线到基线（浅灰）
        const rightXs=xs.filter(v=>v>=b);
        const areaRight=[{x:b,y:0},{x:b,y:pdf0(b)},...rightXs.map(v=>({x:v,y:pdf0(v)})),{x:5,y:0}];
        g.append('path').datum(areaRight).attr('class','area-right').attr('d',area);

        // 曲线与过渡动画
        const p0=g.append('path').datum(data0).attr('fill','none').attr('stroke',col0).attr('stroke-width',4).attr('d',line);
        const p1=g.append('path').datum(data1).attr('fill','none').attr('stroke',col1).attr('stroke-width',4).attr('d',line);
        [p0,p1].forEach(path=>{
          const len=path.node().getTotalLength();
          path.attr('stroke-dasharray',`${len} ${len}`).attr('stroke-dashoffset',len)
              .transition().duration(1400).ease(d3.easeCubicOut).attr('stroke-dashoffset',0);
        });

        // 图例
        const legend=g.append('g').attr('class','legend').attr('transform',`translate(${iw-360},10)`);
        const l0=legend.append('g').attr('transform','translate(0,14)');
        l0.append('line').attr('class','legend-line').attr('x1',0).attr('x2',80).attr('y1',0).attr('y2',0).attr('stroke',col0);
        l0.append('text').attr('x',100).attr('y',7).html('<tspan font-style="italic">p</tspan>(x, y = 0) * <tspan font-style="italic">v</tspan>(x)').style('dominant-baseline','middle');
        const l1=legend.append('g').attr('transform','translate(0,54)');
        l1.append('line').attr('class','legend-line').attr('x1',0).attr('x2',80).attr('y1',0).attr('y2',0).attr('stroke',col1);
        l1.append('text').attr('x',100).attr('y',7).html('<tspan font-style="italic">p</tspan>(x, y = 1) * <tspan font-style="italic">v</tspan>(x)').style('dominant-baseline','middle');

        // ===== Interaction: 鼠标移动显示竖线与两个 PDF 值 =====
        const tip=d3.select('#pdfx-tip');
        const focusLine=g.append('line').attr('y1',0).attr('y2',ih).attr('stroke','#000').attr('stroke-opacity',.2).style('display','none');
        const dot0=g.append('circle').attr('r',4).attr('fill',col0).style('display','none');
        const dot1=g.append('circle').attr('r',4).attr('fill',col1).style('display','none');

        svg.on('mousemove', (ev)=>{
          const [mx] = d3.pointer(ev, g.node());
          const xx = Math.max(-2, Math.min(5, x.invert(mx)));
          const y0 = pdf0(xx), y1 = pdf1(xx);

          focusLine.attr('x1',x(xx)).attr('x2',x(xx)).style('display',null);
          dot0.attr('cx',x(xx)).attr('cy',y(y0)).style('display',null);
          dot1.attr('cx',x(xx)).attr('cy',y(y1)).style('display',null);

          tip.style('opacity',1)
             .style('left',(ev.pageX+12)+'px')
             .style('top', (ev.pageY-10)+'px')
             .html(`<b>x = ${xx.toFixed(2)}</b><br>
                    <span style="color:${col0}">p(x,0)*v(x)</span>: ${y0.toFixed(3)}<br>
                    <span style="color:${col1}">p(x,1)*v(x)</span>: ${y1.toFixed(3)}`);
        }).on('mouseleave', ()=>{
          focusLine.style('display','none');
          dot0.style('display','none');
          dot1.style('display','none');
          tip.style('opacity',0);
        });

        // 可点击切换阴影显示（额外交互）
        let shadeOn=true;
        svg.on('click', ()=>{
          shadeOn=!shadeOn;
          g.selectAll('.area-left,.area-mid,.area-between,.area-right')
           .transition().duration(200).style('opacity', shadeOn? null : 0);
        });
      })();
      </script>
    </section>
  </main>
</body>
</html>
